{"meta":{"title":"Clamee's Blog","subtitle":"","description":"","author":"Clamee","url":"http://example.com","root":"/"},"pages":[{"title":"404","date":"2020-10-07T06:29:01.000Z","updated":"2020-10-07T06:29:01.844Z","comments":true,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":""},{"title":"about","date":"2020-10-14T10:36:29.000Z","updated":"2020-10-14T10:36:29.335Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-10-14T10:54:06.000Z","updated":"2020-10-14T10:54:44.443Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"friend","date":"2020-10-15T00:28:20.000Z","updated":"2020-10-15T02:05:44.777Z","comments":true,"path":"friend/index.html","permalink":"http://example.com/friend/index.html","excerpt":"","text":"Friend Daniel_yuan Imakf LSQS Lightmain Zzt 颓の专区 pokemonshowdown generals"},{"title":"building","date":"2020-10-15T10:35:01.000Z","updated":"2020-10-15T10:35:01.384Z","comments":true,"path":"building/index.html","permalink":"http://example.com/building/index.html","excerpt":"","text":""},{"title":"search","date":"2020-10-14T11:05:48.000Z","updated":"2020-10-14T11:06:12.806Z","comments":true,"path":"search/index.html","permalink":"http://example.com/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-10-14T10:54:59.000Z","updated":"2020-10-14T10:55:20.511Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【学习笔记】高斯整数与 π","slug":"【学习笔记】高斯整数与-π","date":"2021-03-04T13:23:14.000Z","updated":"2021-03-05T07:00:08.881Z","comments":true,"path":"2021/03/04/【学习笔记】高斯整数与-π/","link":"","permalink":"http://example.com/2021/03/04/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E9%AB%98%E6%96%AF%E6%95%B4%E6%95%B0%E4%B8%8E-%CF%80/","excerpt":"","text":"今天看了一个很经典的题目 link。 本博客会讨论一些与圆上整点技术相关的公式。 这十分有趣，所以就来整理一下： 求以原点为圆心，半径为 $\\sqrt{R}$ 的圆的圆周上有多少个点的坐标均是整数。 1、找规律 不妨先打出前几项的表。 $1,4,0,4,8,0,0,4,4,8,0,0,8,0,0,4,0\\cdots$。 令人惊讶的发现，当 $n=4k+3$ 且 $n$ 为质数的时候答案为 $0$，当 $n=4k+1$ 且 $n$ 为质数的时候答案不为 $0$。 2、性质 根据定义可知，原方程相当于是询问存在多少组整数解 (x,y)，满足 $x^2+y^2=r^2$。因为这样的点对实际上是在一个复平面上，如图： 不放在复平面上考虑这个问题： $(x+yi)(x-yi)=x^2+y^2$，$x^2+y^2=R$。 所以我们可以把所有的 $R$ 表示为两个复数分解的形式。 考虑整数的分解是几乎唯一的。 即 $x=p1p2p3p4\\cdots pn$，其中 $pi$ 是质数。那么我们只能同时将两个数乘 $-1$。 扩展到复数域上有 对于一个复数的分解，唯一能做的就是将两个数同乘 $-1,-i$。 现在来考虑原问题，即将 R 分解的问题。考虑到将 R 分解等价于将 R 的每个质因子分解。 考虑到一个性质即所有 $4n+1$ 型的质数可以被分解为 $(2n+i)(2n-i)$ 所以对于每个 $p^k$，可以为答案提供 $k+1$ 的贡献。另外对于 $4n+3$ 型整数，即高斯整数，如果数量为偶数，贡献为 $1$，否则贡献为 $0$。值得注意的是 $2$，它与 -i,-1 的意义相同，不造成贡献。 于是就得到了一个解决方案。","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"【游记】WC2021 游记","slug":"【游记】WC2021-游记","date":"2021-02-05T11:06:32.000Z","updated":"2021-02-05T11:40:48.386Z","comments":true,"path":"2021/02/05/【游记】WC2021-游记/","link":"","permalink":"http://example.com/2021/02/05/%E3%80%90%E6%B8%B8%E8%AE%B0%E3%80%91WC2021-%E6%B8%B8%E8%AE%B0/","excerpt":"","text":"DAY 1-DAY 4听课听不懂，自闭力。前几天感觉那个 IOI 题选讲还蛮有意思的，DAY 4 的课就完全听不懂，直接打了一天的 pokemonshowdown。 DAY 5今天其实考的不是很好，但整体上也还是能接受。 一开始把所有题都看了一遍，感觉 T1 很像 HNOI2019 校园旅行，T2 很像 HNOI2018 寻宝游戏。因为这两个题我都做过，所以就对这两个题有了一个大致的构思。 然后觉得 T3 好像特别可做，所以一顿乱推+excrt 打完花了 3h 左右，但是写挂了一直没调出来，此时相当于我花三个小时拿了 40pts。 感觉时间有点紧，就回手把 T2 50 +T1 32的傻逼暴力随手打完。大概还剩 1h 左右。想了想 T1 的其他部分分，感觉 T1 的其它保证特别诡异，不太好写，T2 的话因为寻宝游戏的做法我好像不太记得了，就没有继续深挖。 回去调 T3，发现 excrt 时我的一个特判写挂了，于是改了改，就过了所有的样例，到这里期望的分 32+50+100，感觉很不错。 最后半个小时我干了一个 -20pts 的神必操作。我希望 T3 的分拿得更加稳妥，于是我就加了个 &lt;=1000 的特判，并且自信地将循环节长度设成了 m。 出来期望得分 32+50+80，自己玩崩了。 考完芙卡米说 T2 的暴力分好像有 70，绿水青山把 T2 切掉了。 感觉我又全组垫底了。没办法，技不如人吧。","categories":[],"tags":[{"name":"游记","slug":"游记","permalink":"http://example.com/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"【题解】CF1139D Steps to One","slug":"【题解】CF1139D-Steps-to-One","date":"2021-01-28T14:30:57.000Z","updated":"2021-01-28T23:54:42.687Z","comments":true,"path":"2021/01/28/【题解】CF1139D-Steps-to-One/","link":"","permalink":"http://example.com/2021/01/28/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91CF1139D-Steps-to-One/","excerpt":"","text":"我有一个不一样的推式子方法。 先将问题转换一下，假设当前的 gcd $x=p1^{k1}p2^{k2}\\cdots$，即为求： E(\\max(\\forall i,\\min(k_i)=0))不妨将每个质数 $p$ 看成一个物品， 假设 $x$ 是新插入集合的数，不妨将 $x$ 看成一个这样的操作： 将与 $x$ 互质的物品取走。 现在问题转化成了一个取物品的的问题，即为求： E(\\max(S))那么直接 Min-max 容斥： E(max(S)=\\sum_{T\\in S}(-1)^{|T|+1}E(min(T)=\\sum_{T\\in S}(-1)^{|T+1|}\\frac{1}{P(T)}考虑当 $\\prod_{x\\in T}x&gt;n$ 时 $P(T)=1$，且 $x$ 为质数，于是可以将式子改写: E(max(S))=\\sum_{T\\in S}(-1)^{|T|+1}-\\sum_{i=2}^n \\mu(i)+\\sum_{i=2}^n \\mu(i)\\lfloor\\frac{n}{i}\\rfloor=1-\\sum_{i=2}^n \\mu(i)+\\sum_{i=2}^n \\mu(i)\\lfloor\\frac{n}{i}\\rfloor然后问题就解决了。 12345678910111213141516171819202122232425262728293031323334int qmod(int x,int y)&#123; int ans&#x3D;1; while(y) &#123; if(y&amp;1)(ans*&#x3D;x)%&#x3D;M; (x*&#x3D;x)%&#x3D;M; y&gt;&gt;&#x3D;1; &#125; return ans;&#125;signed main()&#123; n&#x3D;read(); int inv&#x3D;qmod(n,M-2); for(rg int i&#x3D;2;i&lt;&#x3D;n;i++) &#123; if(!vis[i])p[++len]&#x3D;i,u[i]&#x3D;1; for(rg int j&#x3D;1;j&lt;&#x3D;len&amp;&amp;p[j]*i&lt;&#x3D;n;j++) &#123; vis[i*p[j]]&#x3D;1; if(i%p[j]&#x3D;&#x3D;0)break; u[i*p[j]]&#x3D;-u[i]; &#125; sum&#x3D;(sum-u[i]+M)%M; &#125; for(rg int i&#x3D;2;i&lt;&#x3D;n;i++) &#123; if(u[i]&#x3D;&#x3D;0)continue; mul[i]&#x3D;n*qmod(n-n&#x2F;i,M-2); sum&#x3D;(sum+u[i]*mul[i]%M+M)%M; &#125; write((sum+1)%M);&#125;","categories":[],"tags":[{"name":"容斥","slug":"容斥","permalink":"http://example.com/tags/%E5%AE%B9%E6%96%A5/"},{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"从零开始学数论","slug":"从零开始学数论","date":"2021-01-21T13:22:16.000Z","updated":"2021-01-21T13:22:16.767Z","comments":true,"path":"2021/01/21/从零开始学数论/","link":"","permalink":"http://example.com/2021/01/21/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%95%B0%E8%AE%BA/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"【题解】[WC2016]论战捆竹竿","slug":"【题解】-WC2016-论战捆竹竿","date":"2021-01-02T09:20:39.000Z","updated":"2021-01-02T12:06:40.364Z","comments":true,"path":"2021/01/02/【题解】-WC2016-论战捆竹竿/","link":"","permalink":"http://example.com/2021/01/02/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-WC2016-%E8%AE%BA%E6%88%98%E6%8D%86%E7%AB%B9%E7%AB%BF/","excerpt":"","text":"题目： 竹林里有无数根完全一样的短竹子,每一根竹子由 n 节组成,每一节都被染上了颜色,竹子不可以颠倒。每次你可以选择一根短竹子,短竹子底端若干节(可以是 0节)与竹竿的最上面若干节对应地一节一节捆起来,而短竹子前面剩下的节伸出去,这样就得到了一根更长的竹竿。小 W 对竹竿的审美要求很高,他捆竹竿时有一个癖好:如果两根竹子的某两节被捆在了一起,那么它们的颜色必须相同。现在请你求出在竹竿长度超过 w 的情况下,小 W 可以捆出多少种长度不同的竹竿。其中,竹竿的长度指从底端到顶端的竹子的节的个数。$n \\le 5 \\cdot 10^5 ,w \\le 10^{18}$。 众所周知 $border$ 有一个性质： 字符串 $S$ 的所有 border 可以被划分成不超过 $\\log_2|S|$ 段，每一段的长度是等差数列。 假设现在有 $k$ 个等差数列。 不妨，先考虑其中的一个：$x_1,x_1+d_1,x_1+2d_1,\\cdots,x_1+len*d_1$。 考虑求出在 $\\bmod x_1$ 意义下的同余最短路。其实可以发现，所有的转移会将序列分为 $\\gcd(x_1,d_1)$ 个环。从环上 $dis$ 最小的点开始转移即可。 考虑现在新加入了：$x_2,x_2+d_2,x_2+2d_2,\\cdots,x_2+len*d_2$。 那么现在的模数要切换到 $x_2$。可以发现首先有 $dis’_{dis_i \\bmod x2}=dis_i$ 但这样转移是会漏情况的，因为还有 $dis_i+k*x_1$ 的转移。这样直接再在 $\\bmod x_2$ 意义下跑一遍同余最短路就行了。 之后继续像之前那样考虑 $\\bmod x_2$ 意义下的同余最短路即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;#define il inline#define rg register#define int long longil int read()&#123; int k&#x3D;1,re&#x3D;0;char ch&#x3D;getchar(); while(ch&gt;&#39;9&#39;||ch&lt;&#39;0&#39;)&#123;if(ch&#x3D;&#x3D;&#39;-&#39;)k&#x3D;-1;ch&#x3D;getchar();&#125; while(ch&lt;&#x3D;&#39;9&#39;&amp;&amp;ch&gt;&#x3D;&#39;0&#39;)&#123;re&#x3D;re*10+ch-48;ch&#x3D;getchar();&#125; return re*k;&#125;il void write(int x)&#123; if(x&lt;0)return putchar(&#39;-&#39;),write(-x),void(); if(x&lt;&#x3D;9)return putchar(x+48),void(); return write(x&#x2F;10),write(x%10),void();&#125;int n,T,W,nxt[500005],f[500005],las;char s[500005];int b[500005],lb;const int M&#x3D;998244353;void getb()&#123; int k&#x3D;0; for(rg int i&#x3D;2;i&lt;&#x3D;n;i++) &#123; while(k&amp;&amp;s[i]!&#x3D;s[k+1])k&#x3D;nxt[k]; nxt[i]&#x3D;(s[i]&#x3D;&#x3D;s[k+1])?++k:0; &#125; while(k) &#123; b[++lb]&#x3D;n-k; k&#x3D;nxt[k]; &#125;&#125;int gcd(int u,int v)&#123; if(!v)return u; return gcd(v,u%v);&#125;int st[1000005],ls,p[500005],Q[500005],lq,w[500005],tl,hd,pos[500005];void tomod(int x)&#123; int g&#x3D;gcd(x,las); for(rg int i&#x3D;0;i&lt;las;i++) p[i]&#x3D;f[i]; for(rg int i&#x3D;0;i&lt;x;i++) f[i]&#x3D;0x3f3f3f3f3f3f3f3f; for(rg int i&#x3D;0;i&lt;las;i++) f[p[i]%x]&#x3D;min(p[i],f[p[i]%x]); for(rg int i&#x3D;0;i&lt;g;i++) &#123; ls&#x3D;0;st[++ls]&#x3D;i;int now&#x3D;(i+las)%x; while(st[1]!&#x3D;now) &#123; st[++ls]&#x3D;now; now&#x3D;(now+las)%x; &#125; for(rg int j&#x3D;1;j&lt;&#x3D;ls;j++) &#123; st[ls+j]&#x3D;st[j]; &#125; ls&lt;&lt;&#x3D;1; for(rg int j&#x3D;2;j&lt;&#x3D;ls;j++) f[st[j]]&#x3D;min(f[st[j-1]]+las,f[st[j]]); &#125; las&#x3D;x;&#125;void sol(int x,int sz,int d)&#123; int g&#x3D;gcd(x,d); tomod(x); if(d&lt;0)return; for(rg int i&#x3D;0;i&lt;g;i++) &#123; ls&#x3D;lq&#x3D;0;Q[++lq]&#x3D;i;int now&#x3D;(i+d)%x,tt&#x3D;1; while(Q[1]!&#x3D;now) &#123; if(f[Q[tt]]&gt;f[now])tt&#x3D;lq+1; Q[++lq]&#x3D;now;now&#x3D;(now+d)%x; &#125; for(rg int j&#x3D;tt;j&lt;&#x3D;lq;j++) st[++ls]&#x3D;Q[j]; for(rg int j&#x3D;1;j&lt;tt;j++) st[++ls]&#x3D;Q[j]; hd&#x3D;tl&#x3D;0; w[0]&#x3D;f[st[1]]-d;pos[0]&#x3D;1; for(rg int j&#x3D;2;j&lt;&#x3D;ls;j++) &#123; while(hd&lt;&#x3D;tl&amp;&amp;pos[hd]&lt;j-sz)hd++; if(hd&lt;&#x3D;tl)f[st[j]]&#x3D;min(f[st[j]],w[hd]+j*d+x); while(hd&lt;&#x3D;tl&amp;&amp;w[tl]&gt;f[st[j]]-j*d)tl--; w[++tl]&#x3D;f[st[j]]-j*d;pos[tl]&#x3D;j; &#125; &#125;&#125;signed main()&#123; T&#x3D;read(); while(T--) &#123; n&#x3D;read();W&#x3D;read()-n; scanf(&quot;%s&quot;,s+1);lb&#x3D;0; getb();memset(f,0x3f,sizeof(f));memset(nxt,0,sizeof(nxt));las&#x3D;n; f[0]&#x3D;0;b[lb+1]&#x3D;0; for(rg int i&#x3D;1,j&#x3D;1;i&lt;&#x3D;lb;i&#x3D;j) &#123; while(b[i+1]-b[i]&#x3D;&#x3D;b[j+1]-b[j])j++; sol(b[i],j-i-1,b[i+1]-b[i]); &#125; int ans&#x3D;0; for(rg int i&#x3D;0;i&lt;las;i++) &#123; if(f[i]&lt;&#x3D;W) ans+&#x3D;(W-f[i])&#x2F;las+1; &#125; write(ans);puts(&quot;&quot;); &#125;&#125;","categories":[],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"最短路","slug":"最短路","permalink":"http://example.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"【游记】CSP 游记","slug":"CSP-游记","date":"2020-12-30T15:59:59.000Z","updated":"2020-12-07T14:05:20.571Z","comments":true,"path":"2020/12/30/CSP-游记/","link":"","permalink":"http://example.com/2020/12/30/CSP-%E6%B8%B8%E8%AE%B0/","excerpt":"","text":"由于我的 blog 不会自动更新修改时间，为了防止引起恐慌，故 blog 更新时间不会显示原本的更新时间。 Part 1. S1DAY -2~DAY -1Ys 让我们考了三场试，全都考得贼差，心态崩了。 考试的时候笔用完了，考前就去文具店买了几只那种 $1$ 元钱的笔。 初赛前复习了一下补码反码什么的，然后其它的都没怎么看。 DAY 1上午 7:10 不到就跑到机房来了，等到 7:20 左右 ovor 来说是要到校门口集合。然后又来了几个人说不要。我也不是很懂。 8:10 去做车。有幸做 春日野悠 先生的旁边。路上问了他一个题，然后被他随手 cut 了。我又被打击到了。途中经过了 SDFZ，Imakf 拍了几张照，和去年一模一样呢。 到 湖南大学 以后有人找 Imakf，qiuly，踢个人 去签名。今年也见到了 老K ，只不过今年 zzt 比较走运没被 a 而已。 卷子感觉比去年简单。但我阅读理解第三题还是炸的差不多。最后就蒙了个期望得分。蒙对了香农是我没想到的。 考试的时候好多考场的钟坏了，这不是那个都市传说吗？相信聪明的你也是可以理解的吧。总之 +1s 就对了。 考完回来在车上和绿水青山谈笑风生了一波。 中午在 金拱门 吃的中饭。然后还被 T 神拉去打了会篮球。 Part 2. S2复赛就美妙的考崩了，我也不知道怎么回事。 DAY 1开考前做大巴车坐了好久，Imakf 又拍了张 FZ 的照。 开考后看到第一题就感觉出题人特别强，直接给整蒙了，好在这个题最后只打了 1h 多一点。考完发现有一个小点判错了，最后给官方数据扣了 10pts。 第二题 20min 打完就没管了，最后又出了神奇的错误，导致 100-&gt; 65。 然后觉得 T4 比 T3 简单开 T4。 然后我又神奇的把被吃序列和吃人序列搞反了，最后只有 20pts。 T3 最后打了纯暴力没取模拿了 10pts。好像这题线段树二有 70pts，不由对出题人由衷地钦佩。 晚上去咖啡之翼吃的晚饭，回去之后感觉整个人都不好了。","categories":[],"tags":[{"name":"Other","slug":"Other","permalink":"http://example.com/tags/Other/"}]},{"title":"【题解】ABC163F path pass i","slug":"【题解】ABC163F-path-pass-i","date":"2020-12-27T13:12:53.000Z","updated":"2020-12-27T13:22:32.114Z","comments":true,"path":"2020/12/27/【题解】ABC163F-path-pass-i/","link":"","permalink":"http://example.com/2020/12/27/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91ABC163F-path-pass-i/","excerpt":"","text":"题目大意： 给定一棵树,每个节点有颜色。询问经过每一种颜色的简单路径有多少条。节点数量 $1 \\le n \\le 2\\cdot 10^5$。 对于每个点，直接求出有多少对点符合条件且不经过它既可，这可以使用树形 dp 简单的解决，然后容斥掉即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;#define int long long struct ss&#123; int node,nxt;&#125;e[600005];inline int read()&#123; int re&#x3D;0,k&#x3D;1;char ch&#x3D;getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)&#123;if(ch&#x3D;&#x3D;&#39;-&#39;)k&#x3D;-1;ch&#x3D;getchar();&#125; while(ch&gt;&#x3D;&#39;0&#39;&amp;&amp;ch&lt;&#x3D;&#39;9&#39;)&#123;re&#x3D;(re&lt;&lt;1)+(re&lt;&lt;3)+ch-48;ch&#x3D;getchar();&#125; return re*k;&#125;int u,v,n,col[200005],f[200005],del[200005],s[200005],sz[200005],head[200005],tot,g[200005];void add(int u,int v)&#123; e[++tot].nxt&#x3D;head[u]; e[tot].node&#x3D;v; head[u]&#x3D;tot;&#125;void getsz(int x,int fa)&#123; for(int i&#x3D;head[x];i;i&#x3D;e[i].nxt) &#123; int t&#x3D;e[i].node; if(t&#x3D;&#x3D;fa)continue; getsz(t,x); sz[x]+&#x3D;sz[t]; &#125;&#125;void dfs(int x,int fa)&#123; int lst&#x3D;s[col[fa]]; s[col[fa]]&#x3D;x; if(s[col[x]])del[s[col[x]]]+&#x3D;sz[x]; else g[col[x]]+&#x3D;sz[x]; for(int i&#x3D;head[x];i;i&#x3D;e[i].nxt) &#123; int t&#x3D;e[i].node; if(t&#x3D;&#x3D;fa)continue; dfs(t,x); &#125; int now&#x3D;sz[x]-del[x]; &#x2F;&#x2F;cerr&lt;&lt;col[fa]&lt;&lt;&quot; &quot;&lt;&lt;now&lt;&lt;&quot; &quot;&lt;&lt;sz[x]&lt;&lt;endl; f[col[fa]]+&#x3D;now*(now+1)&gt;&gt;1; s[col[fa]]&#x3D;lst;&#125;signed main()&#123; n&#x3D;read(); for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; col[i]&#x3D;read();sz[i]&#x3D;1; &#125; for(int i&#x3D;1;i&lt;&#x3D;n-1;i++) &#123; u&#x3D;read(); v&#x3D;read(); add(u,v); add(v,u); &#125; getsz(1,0); dfs(1,0); for(int i&#x3D;1;i&lt;&#x3D;n;i++) g[i]&#x3D;(n-g[i])*(n-g[i]+1)&gt;&gt;1; int ans&#x3D;n*(n+1)&gt;&gt;1; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; printf(&quot;%lld\\n&quot;,ans-f[i]-g[i]); &#125;&#125;","categories":[],"tags":[{"name":"容斥","slug":"容斥","permalink":"http://example.com/tags/%E5%AE%B9%E6%96%A5/"}]},{"title":"【题解】NOI2014 魔法森林","slug":"【题解】NOI2014-魔法森林","date":"2020-12-27T13:02:10.000Z","updated":"2020-12-27T13:04:34.176Z","comments":true,"path":"2020/12/27/【题解】NOI2014-魔法森林/","link":"","permalink":"http://example.com/2020/12/27/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91NOI2014-%E9%AD%94%E6%B3%95%E6%A3%AE%E6%9E%97/","excerpt":"","text":"题目大意： 从 $s$ 到 $t$ 找到一条路径 $S$，使得 $\\max_{i\\in S}a_i+\\max_{i\\in S}b_i$ 最小。 做的时候被那个 5e4 整晕了。 所以直接就用分块做这个题了。 考虑枚举最小的 $a_i$，不难发现这个时候最小的 $b_i$ 随 $a_i$ 的增大单调不增，所以是可以双指针的。 考虑使用并查集来判断当前答案的合法性，既考虑将所有满足条件的边连完后 $s$ 和 $t$ 是否连通，不难想到用分块优化复杂度。 即每次将零散块部分暴力插入并查集再撤销。 复杂度为 $O(m\\sqrt{n\\log_2n})$。 实际上由于数据较水所以跑得很快。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;#define il inline#define rg register&#x2F;&#x2F;#define int long longil int read()&#123; int re&#x3D;0,k&#x3D;1;char ch&#x3D;getchar(); while(ch&gt;&#39;9&#39;||ch&lt;&#39;0&#39;)&#123;if(ch&#x3D;&#x3D;&#39;-&#39;)k&#x3D;-1;ch&#x3D;getchar();&#125; while(ch&lt;&#x3D;&#39;9&#39;&amp;&amp;ch&gt;&#x3D;&#39;0&#39;)&#123;re&#x3D;re*10+ch-48;ch&#x3D;getchar();&#125; return re*k;&#125;il void write(int x)&#123; if(x&lt;0)return putchar(&#39;-&#39;),write(-x),void(); if(x&lt;10)return putchar(x+&#39;0&#39;),void(); return write(x&#x2F;10),putchar(x%10+&#39;0&#39;),void();&#125;const int B&#x3D;800;int n,m,ans;struct ss&#123; int u,v,a,b; bool operator &lt;(const ss ot)const&#123; return a&lt;ot.a; &#125;&#125;e[10000005];struct st&#123; int u,v,b; bool operator &lt;(const st ot)const&#123; return b&lt;ot.b; &#125;&#125;now[10000005];int fa[10000005],sz[10000005],s[10000005],ls,lnow,las;bool vis[10000005];void merge(int u,int v)&#123; if(u&#x3D;&#x3D;v)return; if(sz[u]&gt;sz[v])swap(u,v); fa[u]&#x3D;v; sz[v]+&#x3D;sz[u]; s[++ls]&#x3D;u;&#125;int find(int x)&#123; if(x&#x3D;&#x3D;fa[x])return x; return find(fa[x]);&#125;void redo()&#123; sz[fa[s[ls]]]-&#x3D;sz[s[ls]]; fa[s[ls]]&#x3D;s[ls]; ls--;&#125;bool pd(int x)&#123; redo(); lnow--; int t&#x3D;ls; for(rg int i&#x3D;las;i&lt;&#x3D;x;i++) &#123; if(e[i].b&gt;now[lnow].b)continue; merge(find(e[i].u),find(e[i].v)); &#125; if(find(n)&#x3D;&#x3D;find(1))&#123;while(ls&gt;t)redo();return 1;&#125; while(ls&gt;t)redo(); lnow++; merge(find(now[lnow].u),find(now[lnow].v)); return 0;&#125;void init()&#123; for(rg int i&#x3D;1;i&lt;&#x3D;n;i++) fa[i]&#x3D;i,sz[i]&#x3D;1;&#125;void build()&#123; init(); for(rg int i&#x3D;1;i&lt;&#x3D;lnow;i++) &#123; if(find(now[i].u)!&#x3D;find(now[i].v))vis[i]&#x3D;1; else vis[i]&#x3D;0; merge(find(now[i].u),find(now[i].v)); &#125;&#125;signed main()&#123; n&#x3D;read();m&#x3D;read(); for(rg int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; e[i].u&#x3D;read();e[i].v&#x3D;read(); e[i].a&#x3D;read();e[i].b&#x3D;read(); &#125; sort(e+1,e+m+1); init(); ans&#x3D;0x3f3f3f3f; int st&#x3D;1; init(); while(find(1)!&#x3D;find(n)&amp;&amp;st&lt;&#x3D;m) &#123; now[++lnow].u&#x3D;e[st].u; now[lnow].v&#x3D;e[st].v; now[lnow].b&#x3D;e[st].b; merge(find(e[st].u),find(e[st].v)); st++; &#125; sort(now+1,now+lnow+1); build(); las&#x3D;st; do &#123; while(!vis[lnow]&amp;&amp;lnow) lnow--; &#125; while(pd(st-1)); if(find(1)&#x3D;&#x3D;find(n)) &#123; ans&#x3D;e[st-1].a+now[lnow].b; &#125; for(rg int i&#x3D;st;i&lt;&#x3D;m&amp;&amp;lnow&gt;0;i++) &#123; do &#123; while(!vis[lnow]&amp;&amp;lnow) lnow--; &#125; while(pd(i)); if(lnow&gt;0) ans&#x3D;min(ans,e[i].a+now[lnow].b); if(i-las+1&#x3D;&#x3D;B) &#123; int t&#x3D;lnow; for(rg int j&#x3D;las;j&lt;&#x3D;i;j++) &#123; if(e[j].b&gt;now[t].b)continue; now[++lnow].u&#x3D;e[j].u; now[lnow].v&#x3D;e[j].v; now[lnow].b&#x3D;e[j].b; &#125; las&#x3D;i+1; sort(now+1,now+lnow+1); build(); &#125; &#125; if(ans&#x3D;&#x3D;0x3f3f3f3f) ans&#x3D;-1; write(ans);&#125;","categories":[],"tags":[{"name":"分块","slug":"分块","permalink":"http://example.com/tags/%E5%88%86%E5%9D%97/"},{"name":"并查集","slug":"并查集","permalink":"http://example.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"NOIP 有感","slug":"NOIP-有感","date":"2020-12-08T10:28:44.000Z","updated":"2020-12-08T13:11:26.332Z","comments":true,"path":"2020/12/08/NOIP-有感/","link":"","permalink":"http://example.com/2020/12/08/NOIP-%E6%9C%89%E6%84%9F/","excerpt":"","text":"【序章】卷与卷王国 在 OI 大陆上，有一个王国叫做卷王国。卷王国的国王卷励精图治，创造一番盛世之景。 为了防止官员腐化堕落，卷规定：“每个官员的任期有限”。他自己也谨遵这一条准则，在担任了 114514 年国王之后，隐居深山。他在位时，着手提高官员工资，提高税收，力促官员清廉，颇有成效。他上过《卷国青年报》，百姓也对他津津乐道。 卷的执政也不总是一帆风顺的，他在位之时有一商会名曰西哥商会，势力庞大。卷历 114504 年，因为国家财政问题，卷向西哥商会借了十万枚金币。之后由于连年天灾，卷国的税收不上来，但西哥商会由于其垄断性质，赚的盆满钵满。于是卷还想向西哥商会借十万枚金币。西哥商会的会长西哥很不乐意，断然拒绝。卷为了为民伸张正义，于是指使部下用手榴弹把西哥商会炸了。此后西哥商会挟持资本分裂国家，在卷国的西方成立了一个新的国家，名曰颓国。 卷退位之后隐居深山，经常为迷路的人指点方向，为求学的人传授知识，他的事迹被口口相传，后人尊称他为卷大师。卷大师有一手绝活，叫闪电五连鞭，没有一定觉悟的人都是学不会的。 而西哥是个不折不扣的独裁者，一直把持着颓国的政治经济文化大权，决定着颓国的大小事务。但由于颓国家底厚，国力强，没人敢对此说些什么。 转眼间，时间过去了很久。卷国的国王换了一代又一代，到了羽的手里。在羽的任上，经济衰退，民不聊生，起义频发。不久，卷国北部爆发了由小蝙蝠卡米领导的起义，成立了一个新国度，名叫懂国。羽深感无力，于是想找一个继承人。便举办了卷国第一届大选。 【第一章】AK-思齐 丹是一位卷国的贵族。他想参加卷国的大选。 卡米邀请丹去懂国做客，他知道，如果丹当选，必然实行一系列有利于卷国的政策。只是令他没想到的是，丹一口就答应了。 「你可真是奇怪的人呢。」丹举起酒杯，说道。 「那么，我刚才说的，您是否赞同呢？」卡米脸上露出了邪魅的笑容。 「2.07 亿是吧，这个要价真是低廉呢。」 「这么说您是同意了吗？」 「只是有一个要求哦，我对您的枪很感兴趣，可以借我试一试吗？」 「那就送你了吧，这把枪叫 AK-思齐，是这个大陆上最好的抢呢。」 「啊，可真是一把好枪呢。」丹回到了卷国，打开了卡米给他的枪套。 「那么，就按卡米说的做吧」他暗暗地想到。然后叫了几个好友去打猎。他的这把 AK-思齐 斩获了最多的猎物。打猎的最后，丹正式向国王之位提出挑战，他举起了他最爱的 AK-思齐，向天鸣枪。他的好友对他表示完全的支持。在之后的一段日子里，这把 AK-思齐 一直是丹的宝贝，形影不离。 持续更新中……","categories":[],"tags":[{"name":"游记","slug":"游记","permalink":"http://example.com/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"字符串总结","slug":"浅谈回文自动机","date":"2020-10-25T13:04:20.000Z","updated":"2020-10-29T12:58:31.070Z","comments":true,"path":"2020/10/25/浅谈回文自动机/","link":"","permalink":"http://example.com/2020/10/25/%E6%B5%85%E8%B0%88%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA/","excerpt":"","text":"HashHash 是最简单同时也是泛用性最强的字符串算法。它的思想很简单：设计 Hash 函数 $f$，两个字符串的 hash 函数值一样时两个字符串一样，否则两个字符串不一样。在设计 Hash 函数时，我们主要关心的是时间复杂度和准确率。例如有一些提高准确率的方法：自然溢出、多模数 Hash…… 在大多数情况下，形如 $f(x)=A+Bx+Cx^2\\cdots$ 是一种简单高效的 Hash。下面的 Skip 也是基于这种 Hash 方法。 Skip：快速得到子串 Hash 值 给定一个串 $s$，每次查询子串 $s[l:r]$ 的 Hash 值。 设 $g(i)$ 表示 $s[1:i]$ 的 Hash 值。 考虑我们的 $hash$ 函数时实际上是一个多项式，那么有 $g(i)=x*g(i-1)+b$。 可以发现，对于前 $l-1$ 个元素，它们对 $g(r)$ 的贡献为 $x^{r-l+1}g(l-1)$。 将这个贡献减掉，就可以得到正确的 $Hash$ 值。 即 $f(s[l:r])=f([s[1:r]])-x^{r-l+1}f(s[1:l-1])$。 KMP 求前缀函数给定一个长度为 $n$ 的字符串 $s$，其 前缀函数 被定义为一个长度为 $n$ 的数组 $\\pi$ 。其中 $\\pi[i]$ 的定义是： $s[1:i]$ 的最长真 border 长度。 这里不妨先讲一下 border。 border 和 border 的性质 Hillary: Open the border. Trump: Build a wall. DAN: I AK IOI. border 是一个字符串相同前缀和后缀。 例如在字符串 daniel_dandandan 中，$\\varnothing,dan,daniel$_$dandandan$ 都是该字符串的 border。 border 的性质 字符串 $S$ 的所有 border 可以被划分成不超过 $\\log_2|S|$ 段，每一段的长度是等差数列。 证明： 引理 $1$：若字符串 $S$ 存在一个长度为 $k$ 的 border，那么 $|S|-k$ 为字符串的一个周期。 引理 $2$：若 $p,q$ 为字符串的周期且 $p+q\\le|S|-gcd(p,q) $，那么 $gcd(p,q)$ 也为字符串的一个周期。 考虑 border 大于 $\\frac{|S|}{2} $ 的情况，由引理一得 $q=|S|-k $ 为 $S$ 的最小周期，其中 $k$ 为 $S$ 的最长 border，由引理二得 $|S|-aq\\geq \\frac{|S|}{2} $ 为 $S$ 的 $border$。 递归证明 border 小于 $\\frac{|S|}{2} $ 即可。 回文 border 是一个回文的 border。 类似地，回文 border 也有如上性质，读者可以自行证明。 这里只给出结论：字符串 $S$ 的所有回文 border 可以被划分成不超过 $\\log_2|S|$ 段，每一段的长度是等差数列。 这里继续讲前缀函数和 KMP。 KMP 是一个高效的求前缀函数的算法。 这个算法其实很简单。假设我们已经求出了前 $i$ 个位置的前缀函数。求第 $i+1$ 个位置的时候我们不停地跳前缀匹配就行了。 12while(k&amp;&amp;s2[k+1]!&#x3D;s2[i+1])k&#x3D;nxt[k];nxt[i+1]&#x3D;(s2[i+1]&#x3D;&#x3D;s2[k+1])?(++k):0; 代码就两行。 因为 while 每执行一次 $k$ 至少减少 $1$，$k$ 最多增加 $n$ 所以复杂度是线性的。 ManacherManacher 算法可以求出以每个位置为回文中轴的回文半径。 用前面提到的 $ Hash$ 算法套二分可以在 $O(n\\log_2n)$ 的时间复杂度求解。而 Manacher 算法可以做到 $O(n)$。 我们始终维护一个最靠右的最长回文串 $s[l:r]$，记它的中轴为 $mid$。对于以 $x$ 为回文中心的回文串，可以直接找到与它关于$mid$ 对称的位置的回文半径，此时要保证回文串不超过 $r$，因为 $r$ 的右边是未知的，所以要和 $r-x+1$ 取 min，并从回文半径开始更新。最后再更新 $s[l:r]$。 代码： 123if(t&lt;&#x3D;r)ans[t]&#x3D;min(ans[2*mid-t],r-t+1);while(b[ans[t]+t]&#x3D;&#x3D;b[t-ans[t]])ans[t]++;if(t+ans[t]&gt;r)r&#x3D;t+ans[t]-1,mid&#x3D;t; 复杂度分析: 当第一行执行完 t+ans[t]-1&lt;r 时。第二行 ans[t] 不会进行更新。 当 t+ans[t]-1=r 时，每执行一次 while r 都会加 1，因为 r 最大为 n。所以 while 最多执行 n 次。 故复杂度为 $O(n)$。 Z 函数(扩展 KMP)一个字符串的 Z 函数是一个长度为 $n$ 的数组，其中 $z[i]=lcp(s[1:n],s[i:n])$。 求解 Z 函数的方法与 Manacher 类似。 维护一个最靠右的前缀 lcp $s[l:r]$。对于从 x 直接从 $z[x-l+1]$ 开始匹配即可。 代码： 12345if(i&lt;&#x3D;r) z[i]&#x3D;min(z[i-l],r-i+1);while(i+z[i]&lt;n&amp;&amp;s[z[i]]&#x3D;&#x3D;s[i+z[i]])++z[i];if(i+z[i]-1&gt;r) l&#x3D;i,r&#x3D;i+z[i]-1; 读者可以结合 manacher 部分自行分析。 字符串匹配在 OI 学习中，最简单实用的字符串匹配方法是利用前缀函数或字符串 Hash 求匹配。另外也能用 z 函数做字符串匹配。 此外还有更高效的匹配算法，例如 Boyer-Moore 算法，当然博主也不会，博主肯定不会讲。 Hash 方法 对于文本串的每个匹配串长度的的子串求出 Hash 值，和匹配串比较即可。 前缀函数方法 利用前缀函数快速跳 border 匹配。 z 函数方法 用一个分隔符将匹配串和文本串连起来。求 $z$ 函数。通过 $z$ 函数的定义不难发现所有文本串位置 z 函数值为文本串长度的即为匹配位置 Lyndon 分解一些定义： Lyndon 串：字典序小于其所有后缀字典序的字符串。 Lyndon 分解：将一个字符串分解成若干依次字典序非严格递减的 Lyndon 串。 近似 Lyndon 串：一个字符串 $t=ww\\cdots \\overline w$，其中 $w$ 是一个 Lyndon 串。 可以用 Duval 算法来求 Lyndon 分解。(划记：它用到了贪心的思想，初赛可能会考。) 在算法流程中，我们将待分解字符串分成 $s1s2s3$ 相连的三个部分。其中 $s1$ 是一个 Lyndon 串，并且已经求出了它的 Lyndon 分解，$s2$ 是一个近似 Lyndon 串，$s3$ 是未处理的部分。 每次将 $s3$ 的首字符接到 $s2$ 后面，如果 $s2$ 不再是近似 Lyndon 串，就将 $s2$ 的一部分前缀接到 $s1$ 末尾。 代码如下： 12345678910111213141516for(rg int i&#x3D;1,j,k;i&lt;&#x3D;n;)&#123; j&#x3D;i;k&#x3D;i+1; while(k&lt;&#x3D;n&amp;&amp;s[j]&lt;&#x3D;s[k]) &#123; if(s[j]&lt;s[k])j&#x3D;i; else j++; k++; &#125; while(i&lt;&#x3D;j) &#123; ans^&#x3D;(i+k-j-1); i+&#x3D;k-j; &#125;&#125; 可以证明复杂度是 $O(n)$ 的。 最小表示法字符串 $s$ 的最小表示为与 $s$ 循环同构的所有字符串中字典序最小的字符串。 对于长度为 $n$ 的串 $s$，可以用 Lyndon 分解求出最小表示法。 对 $ss$ 进行 Lyndon 分解，找到垮过这两个串的 Lyndon 串的首字母，从它开始之后 $n$ 个数就是 $s$ 的最小表示法。 Trie字典树 Trie，是一种数据结构。 OI wiki 上的图： AC 自动机(ACAM)多匹配串匹配： 给定 $n$个模式串 $s_i$ 和一个文本串 $t$，求有多少个不同的模式串在文本串里出现过。 可以先将这 $n$ 个模式串丢到 trie 上，现在问题变为我们要像构造前缀函数一样构造出函数 $fail$，表示所有字符串与当前节点所代表的字符串的最长 border 所在节点，用 $fail$ 来跑匹配。 可以使用广搜来进行这一过程： 如果我们当前考虑到了一个节点，那么它的 $fail$ 应该指向它的父亲的 $fail$ 连出相同字符边的节点。然后依次进行广搜即可。需要注意如果一个点没有相应字符的边，则将它连到它的 $fail$ 的相应字符边。 代码如下： 12345678910111213141516171819void get_nxt()&#123; queue&lt;int&gt; q; for(int i&#x3D;0;i&lt;&#x3D;25;i++) if(e[0].a[i])e[e[0].a[i]].nxt&#x3D;0,q.push(e[0].a[i]); while(!q.empty()) &#123; int now&#x3D;q.front();q.pop(); for(int i&#x3D;0;i&lt;&#x3D;25;i++) &#123; if(e[now].a[i]) &#123; e[e[now].a[i]].nxt&#x3D;e[e[now].nxt].a[i]; q.push(e[now].a[i]); &#125; else e[now].a[i]&#x3D;e[e[now].nxt].a[i]; &#125; &#125;&#125; 回文自动机(PAM)AC 自动机也由转移边和 fail 指针构成。 在回文自动机上每走一条转移边表示在字符串两边同时加上一个字符。 回文自动机有两个根，一个根表示奇数回文串，一个根表示偶数回文串，分别命名奇根偶根，一开始偶根的 $fail$ 指针指向奇根。 构建方法： 考虑增量法构建。 每次从上一次插入到的点不停跳 $fa$ 满足条件的位置然后将新点连上去即可。简单易懂。 123456789101112131415161718int getfa(int p,int now)&#123; while(s[now]!&#x3D;s[now-e[p].len-1])p&#x3D;e[p].fa; return p;&#125;void add(int x,int now)&#123; int p&#x3D;getfa(las,now); if(!e[p].ch[x]) &#123; e[++tot].len&#x3D;e[p].len+2; int t&#x3D;getfa(e[p].fa,now); e[tot].fa&#x3D;e[t].ch[x]; e[tot].num&#x3D;e[e[tot].fa].num+1; e[p].ch[x]&#x3D;tot; &#125; las&#x3D;e[p].ch[x];&#125; 序列自动机在这个自动机上从源点到每一个节点都是一个原串子序列。 构建方法： 考虑暴力：每次遍历一遍这个自动机，将没有当前值的转移边的节点向新节点连一条边这样是 $O(n)-O(1)$。 用平衡树来优化这一过程可以 $O(\\log_2n)-O(\\log_2n)$。 后缀数组后缀数组 $sa$ 表示字符串每个排名的后缀的首字母位置，可以通过后缀排序求解。后缀排序可以用 DC3 或 SA-IS 做到 $O(n)$。或可以通过倍增算法 + 基数排序做到 $O(n\\log_2n)$。一般在 OI 比赛中，我们主要采用后面的算法。 用 $sa$ 求 $height$ 记 $height_i$ 表示排名为 $i-1$ 与排名为 $i$ 的 $lcp$ 长度。它可以通过 $sa$ 快速求出： 1234567891011121314void geth()&#123; for(int i&#x3D;1;i&lt;&#x3D;n;i++) rk[sa[i]]&#x3D;i; int k&#x3D;0; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; if(rk[i]&#x3D;&#x3D;1)continue; if(k)--k; int j&#x3D;sa[rk[i]-1]; while(i+k&lt;&#x3D;n&amp;&amp;j+k&lt;&#x3D;n&amp;&amp;s[i+k]&#x3D;&#x3D;s[j+k])++k; h[rk[i]]&#x3D;k; &#125;&#125; 后缀自动机考虑增量法构建。 每次分三种情况讨论。 因为这个比较难，看我的博客不一定能看懂，所以还是推荐去看专门讲这个的博客。 123456789101112131415161718192021void add(int x)&#123; int p&#x3D;las;int np&#x3D;las&#x3D;++tot;f[tot]&#x3D;1; e[np].len&#x3D;e[p].len+1; for(;p&amp;&amp;!e[p].ch[x];p&#x3D;e[p].fa)e[p].ch[x]&#x3D;np; if(!p)e[np].fa&#x3D;1; else &#123; int q&#x3D;e[p].ch[x]; if(e[q].len&#x3D;&#x3D;e[p].len+1)e[np].fa&#x3D;q; else &#123; int nq&#x3D;++tot; e[nq]&#x3D;e[q]; e[nq].len&#x3D;e[p].len+1; e[q].fa&#x3D;e[np].fa&#x3D;nq; for(;p&amp;&amp;e[p].ch[x]&#x3D;&#x3D;q;p&#x3D;e[p].fa)e[p].ch[x]&#x3D;nq; &#125; &#125;&#125;","categories":[],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"【题解】[FJOI2016]神秘数","slug":"【题解】-FJOI2016-神秘数","date":"2020-10-17T00:18:31.000Z","updated":"2020-10-17T00:31:26.145Z","comments":true,"path":"2020/10/17/【题解】-FJOI2016-神秘数/","link":"","permalink":"http://example.com/2020/10/17/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-FJOI2016-%E7%A5%9E%E7%A7%98%E6%95%B0/","excerpt":"","text":"题目大意：一个可重复数字集合S的神秘数定义为最小的不能被S的子集的和表示的正整数。 给定一个序列 $a$，每次询问一个区间的神秘数。 很久之前还讲过这个题，当时还要求带修。 考虑加入当前的神秘数为 $x$。当加入一个数 $y$ 且 $y\\le x$ 时神秘数会变为 $x+y$。当 $y&gt;x$ 时对答案不造成贡献。 可以考虑值域倍增，对 $[1,1],[2,3],[4,7],\\cdots,[2^k,2^k-1],\\cdots$ 之间的元素分别维护前缀和和 rmq。 每次查询的时候依次查区间最小值是否小于当前神秘数即可。如果小于的话直接加上区间和去下一个区间，不然直接返回答案。 如果 $O(n)-O(1)$ 求 rmq 的话复杂度可以做到 $O(n\\log\\max(a[i]))$。 我的代码就直接用 st 表了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;#define il inline#define rg register#define ll long longil int read()&#123; int re&#x3D;0,k&#x3D;1;char ch&#x3D;getchar(); while(ch&gt;&#39;9&#39;||ch&lt;&#39;0&#39;)&#123;if(ch&#x3D;&#x3D;&#39;-&#39;)k&#x3D;-1;ch&#x3D;getchar();&#125; while(ch&lt;&#x3D;&#39;9&#39;&amp;&amp;ch&gt;&#x3D;&#39;0&#39;)&#123;re&#x3D;re*10+ch-48;ch&#x3D;getchar();&#125; return re*k;&#125;il void write(int x)&#123; if(x&lt;0)return putchar(&#39;-&#39;),write(-x),void(); if(x&lt;&#x3D;9)return putchar(x+48),void(); return write(x&#x2F;10),write(x%10),void();&#125;int LOG[100005],a[100005],n,m;struct st&#123; int st[100005][17];ll sum[100005]; void init(int liml,int limr) &#123; sum[0]&#x3D;0; for(rg int i&#x3D;1;i&lt;&#x3D;n;i++) if(a[i]&gt;&#x3D;liml&amp;&amp;a[i]&lt;&#x3D;limr)st[i][0]&#x3D;a[i],sum[i]&#x3D;sum[i-1]+a[i]; else st[i][0]&#x3D;0x3f3f3f3f,sum[i]&#x3D;sum[i-1]; for(rg int j&#x3D;1;(1&lt;&lt;j)&lt;&#x3D;n;j++) for(rg int i&#x3D;1;i+(1&lt;&lt;j)&lt;&#x3D;n+1;i++) st[i][j]&#x3D;min(st[i][j-1],st[i+(1&lt;&lt;(j-1))][j-1]); &#125; ll query(int l,int r) &#123; int d&#x3D;LOG[r-l]; return min(st[l][d],st[r-(1&lt;&lt;d)+1][d]); &#125; ll Sum(int l,int r) &#123; return sum[r]-sum[l-1]; &#125;&#125;b[30];signed main()&#123; n&#x3D;read(); for(rg int i&#x3D;1;i&lt;&#x3D;n;i++) a[i]&#x3D;read(); m&#x3D;read(); for(rg int i&#x3D;2;i&lt;&#x3D;n;i++) LOG[i]&#x3D;LOG[i&gt;&gt;1]+1; b[0].init(1,1); for(rg int i&#x3D;1,t&#x3D;2;i&lt;&#x3D;29;i++,t&lt;&lt;&#x3D;1ll) b[i].init(t,t+t-1); for(rg int i&#x3D;1,l,r;i&lt;&#x3D;m;i++) &#123; l&#x3D;read();r&#x3D;read(); ll ans&#x3D;0;int t&#x3D;0; while(t&lt;&#x3D;29) &#123; if(ans+1ll&lt;min(b[t].query(l,r),(1ll&lt;&lt;(t+1))-1)) break; ans+&#x3D;b[t].Sum(l,r); t++; &#125; write(ans+1ll);puts(&quot;&quot;); &#125;&#125;","categories":[],"tags":[{"name":"倍增","slug":"倍增","permalink":"http://example.com/tags/%E5%80%8D%E5%A2%9E/"},{"name":"线段树","slug":"线段树","permalink":"http://example.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"二次剩余学习笔记","slug":"多项式-DLC","date":"2020-10-11T13:04:02.000Z","updated":"2020-10-11T14:29:47.869Z","comments":true,"path":"2020/10/11/多项式-DLC/","link":"","permalink":"http://example.com/2020/10/11/%E5%A4%9A%E9%A1%B9%E5%BC%8F-DLC/","excerpt":"","text":"精通多项式的大家一定见过以下一个问题(如果你实在要说不精通的话就去看 Imakf 的博客，看完就精通了)。 1.多项式开根(加强版) 给定一个 $n-1$ 次多项式 $A(x)$ ，求一个在 $\\bmod {x^n}$ 意义下的多项式 $B(x)$ ，使得 $B^2(x)\\equiv A(x)\\pmod {x^n}$ ，答案取常数项更小的的 $\\sqrt{A(x)}$。 多项式的系数在 $\\bmod 998244353$ 的意义下进行运算。 不保证 $a_0=1$。 先来一波多项式部分的推导： 不妨假设我们求出了 $H^2(x)\\equiv A(x)$，现在要求 $G^2(x)\\equiv A(x)$。 G(x)-H(x)\\equiv 0(\\bmod x^(\\frac{n}{2})\\\\ G^2(x)+H^2(x)-2G(x)H(x)\\equiv 0(\\bmod x^n)\\\\ 2G(x)H(x)\\equiv G^2(x)+H^2(x)(\\bmod x^n)\\\\ G(x)\\equiv \\frac{F(x)+H^2(x)}{2H(x)}(\\bmod x^n) 然后就可以递归求解了。 那么现在递归到常数项的时候有一个问题：如何求 $x_0^2\\equiv y(\\bmod 998244353)$。 那么就要用到一个新知识：二次剩余。 这个玩意使用来求解方程： x^2\\equiv n(\\bmod p)这里要求 $p$ 是奇质数，我们不妨在这里设 $p$ 的原根为 $g$。 判定 判断一个数 $x$ 是不是二次剩余。 这个东西叫欧拉准则。 结论： $x^{\\frac{p-1}{2}}\\equiv 1(\\bmod p)$ 与 $x$ 是二次剩余等价。 推论： $x^{\\frac{p-1}{2}}\\equiv -1(\\bmod p)$ 与 $x$ 是非二次剩余等价。 根据费马小定理有 $x^{\\frac{p-1}{2}}\\equiv 1(\\bmod p)\\Leftrightarrow x^{2\\cdot\\frac{p-1}{2}}\\equiv 1(\\bmod p)\\Leftrightarrow g^{k\\cdot\\frac{p-1}{2}}\\equiv1(\\bmod p)$ 。 可得 $k$ 一定为偶数，那么 $g^{\\frac{k}{2}}$ 是 $x$ 开根的结果，所以 $x$ 是二次剩余， 由于$x^{\\frac{p-1}{2}}\\equiv 1 or-1(\\bmod p)$ 。 求解 判定完了以后可以开始求解了。 我们可以先找到一个 $a$ 使得 $a^2-n\\equiv 0$ 且 $a^2-n$ 是非二次剩余。 至于怎么找，因为非二次剩余数量是 $n/2$ 级别的，所以可以随机。 现在找到一个 $b$ 使得 $b^2 \\equiv a^2-n$。 因为实际上实数域上涨不到这样的 $b$ 所以可以到复数域上找，只不过为了计算方便我们定义 $i^2=a^2-n$。 那么可以通过计算得出 $(a+i)^{p+1}\\equiv n$。 所以得到 $(a+1)^{\\frac{p+1}{2}}$ 是一个解， $-(a+1)^{\\frac{p+1}{2}}$ 是另一个解。","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"【题解】[HA2009]求回文串","slug":"【题解】-HA2009-求回文串","date":"2020-10-08T03:51:33.000Z","updated":"2020-10-15T02:14:30.127Z","comments":true,"path":"2020/10/08/【题解】-HA2009-求回文串/","link":"","permalink":"http://example.com/2020/10/08/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-HA2009-%E6%B1%82%E5%9B%9E%E6%96%87%E4%B8%B2/","excerpt":"","text":"题目大意： 给你一个长度为 $n$ 的字符串，每次可以交换相邻的两个字符，求最小的交换次数使得将字符串变成回文串($n\\le 10^6$)。 可以考虑终止状态和起始状态的联系，可以构建序列 b 表示依次给每个字符找到原序列中的对应字符的出现位置，答案即为 b 数组的逆序对数。 例如： 12abbcaabcba 构建出来的序列为 1 2 4 3 5，所以答案为 $1$。 那么我们就将问题转化为求出一个序列使得它对应上去了以后逆序对数最小。 考虑任意两种字符之间的贡献不难发现，我们可以钦定所有字符的左边不动，只改变右边。于是我们可以构造出一个新的序列。然后求一波逆序对即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;#define il inline#define rg register#define int long longchar s[1000005];il int read()&#123; int re&#x3D;0,k&#x3D;1;char ch&#x3D;getchar(); while(ch&gt;&#39;9&#39;||ch&lt;&#39;0&#39;)&#123;if(ch&#x3D;&#x3D;&#39;-&#39;)k&#x3D;-1;ch&#x3D;getchar();&#125; while(ch&lt;&#x3D;&#39;9&#39;&amp;&amp;ch&gt;&#x3D;&#39;0&#39;)&#123;re&#x3D;re*10+ch-48;ch&#x3D;getchar();&#125; return re*k;&#125;il void write(int x)&#123; if(x&lt;0)return putchar(&#39;-&#39;),write(-x),void(); if(x&lt;10)return putchar(x+48),void(); return write(x&#x2F;10),putchar(x%10+48),void();&#125;int n,t[26],p[1000005],r[26],b[1000005];int tree[1000005],cnt;bool vis[1000005];void add(int x)&#123; while(x&lt;&#x3D;n) &#123; tree[x]++; x+&#x3D;x&amp;-x; &#125;&#125;int sum(int x)&#123; int re&#x3D;0; while(x) &#123; re+&#x3D;tree[x]; x-&#x3D;x&amp;-x; &#125; return re;&#125;int abs2(int x)&#123; return x&gt;0?x:-x;&#125;signed main()&#123; scanf(&quot;%s&quot;,s+1); n&#x3D;strlen(s+1); for(rg int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; int now&#x3D;s[i]-&#39;A&#39;; t[now]++; p[i]&#x3D;r[now]; r[now]&#x3D;i; &#125; for(rg int i&#x3D;0;i&lt;26;i++) &#123; if(t[i]&amp;1) &#123; if(cnt) &#123; puts(&quot;-1&quot;);return 0; &#125; cnt&#x3D;i; &#125; &#125; if(cnt) &#123; int now&#x3D;r[cnt],las&#x3D;0; for(int i&#x3D;1;i&lt;&#x3D;t[cnt]&#x2F;2;i++) &#123; now&#x3D;p[now]; &#125; if(las) p[las]&#x3D;p[now]; b[n&#x2F;2+1]&#x3D;now; vis[now]&#x3D;1; &#125; int ans&#x3D;0,ss&#x3D;0; for(rg int i&#x3D;1;i&lt;&#x3D;n&#x2F;2+ss;i++) &#123; if(vis[i])&#123;ss++;continue;&#125; int now&#x3D;s[i]-&#39;A&#39;; vis[i]&#x3D;vis[r[now]]&#x3D;1; b[i-ss]&#x3D;i;b[n-i+ss+1]&#x3D;r[now]; r[now]&#x3D;p[r[now]]; &#125; for(int i&#x3D;n;i&gt;&#x3D;1;i--) &#123; ans+&#x3D;sum(b[i]); add(b[i]); &#125; write(ans);&#125;","categories":[],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"树状数组","slug":"树状数组","permalink":"http://example.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"贪心","slug":"贪心","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"Welcome to clamee's new blog!","slug":"Welcome-to-clamee-s-new-blog","date":"1926-08-17T03:45:14.000Z","updated":"2020-10-08T03:30:20.917Z","comments":true,"path":"1926/08/17/Welcome-to-clamee-s-new-blog/","link":"","permalink":"http://example.com/1926/08/17/Welcome-to-clamee-s-new-blog/","excerpt":"","text":"致 daisiki の米娜桑， 马上就要吃午饭了呢,在这个特殊的日子里。 能在这个美妙的时间搭建我的新博客，对于我而言是非常~开心的哦。以后如果大家想到我的博客来转转，我是非常~欢迎的呢。 大约两年前我在 luogu 开通了我的第一个博客，之后也会基本搬运过来。但这不意味着在 luogu 上停更，以后在 luogu 博客上我还是会发布一些题解。以后大部分的题解，以及所有的其他内容都会在这里发表。至于要不要同步当然是看皮(wo)卡(zi)丘(ji)的的心情啦，毕竟皮卡丘的意愿也是很重要的呢。 在搭建博客的过程中 T 神给了我极大的帮助，在这里非常感谢。顺便一提，T 神是个很可爱的妹子呢(虽然说可爱的一直都只有男孩子而已呢)。 今天感觉是个很重要的日子呢，感觉会有大事发生，会有什么有名的长者之类的人物诞生吗，我也不知道，但是相信屏幕前的你也是可以明白的吧。啊，要到饭点了呢，大家都赶紧去吃饭吧。","categories":[],"tags":[{"name":"Other","slug":"Other","permalink":"http://example.com/tags/Other/"}]}],"categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"游记","slug":"游记","permalink":"http://example.com/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"容斥","slug":"容斥","permalink":"http://example.com/tags/%E5%AE%B9%E6%96%A5/"},{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"最短路","slug":"最短路","permalink":"http://example.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"Other","slug":"Other","permalink":"http://example.com/tags/Other/"},{"name":"分块","slug":"分块","permalink":"http://example.com/tags/%E5%88%86%E5%9D%97/"},{"name":"并查集","slug":"并查集","permalink":"http://example.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"倍增","slug":"倍增","permalink":"http://example.com/tags/%E5%80%8D%E5%A2%9E/"},{"name":"线段树","slug":"线段树","permalink":"http://example.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"树状数组","slug":"树状数组","permalink":"http://example.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"贪心","slug":"贪心","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83/"}]}